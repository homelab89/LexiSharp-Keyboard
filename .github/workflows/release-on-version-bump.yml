name: Release on Version Bump

on:
  push:
    branches: ["main", "master"]
    paths:
      - "app/build.gradle"
      - "app/build.gradle.kts"
      - "gradle.properties"
      - "app/src/main/AndroidManifest.xml"
  workflow_dispatch: {}

concurrency:
  group: release-on-version-bump
  cancel-in-progress: false

jobs:
  release:
    name: Build and Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # è·å–å®Œæ•´å†å²ä»¥ä¾¿æ£€æµ‹ç‰ˆæœ¬å˜åŒ–

      - name: Set up Java 21
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "21"
          cache: "gradle"

      - name: Validate Gradle Wrapper
        uses: gradle/wrapper-validation-action@v2
        continue-on-error: true
        timeout-minutes: 2

      - name: Set up Gradle
        uses: gradle/actions/setup-gradle@v3

      - name: Detect version change
        id: version
        env:
          GITHUB_EVENT_BEFORE: ${{ github.event.before }}
        run: |
          python3 - <<'PY'
          import os, re, subprocess

          def read_file(path):
              try:
                  with open(path, 'r', encoding='utf-8') as f:
                      return f.read()
              except FileNotFoundError:
                  return None

          def parse_versions(text):
              if not text:
                  return None, None
              vn = None
              vc = None
              m = re.search(r'versionName\s*[= ]\s*"?([0-9A-Za-z\.-_\+]+)"?', text)
              if m:
                  vn = m.group(1)
              m = re.search(r'versionCode\s*[= ]\s*"?([0-9]+)"?', text)
              if m:
                  vc = m.group(1)
              if vn is None:
                  m = re.search(r'(?im)^\s*(?:VERSION_NAME|versionName)\s*=\s*([^\s#]+)', text)
                  if m:
                      vn = m.group(1).strip()
              if vc is None:
                  m = re.search(r'(?im)^\s*(?:VERSION_CODE|versionCode)\s*=\s*([0-9]+)', text)
                  if m:
                      vc = m.group(1).strip()
              if vn is None:
                  m = re.search(r'android:versionName\s*=\s*"([^"]+)"', text)
                  if m:
                      vn = m.group(1)
              if vc is None:
                  m = re.search(r'android:versionCode\s*=\s*"([^"]+)"', text)
                  if m:
                      vc = m.group(1)
              return vn, vc

          def get_file_at_rev(path, rev=None):
              if rev is None:
                  return read_file(path)
              try:
                  out = subprocess.check_output(['git', 'show', f'{rev}:{path}'], stderr=subprocess.STDOUT)
                  return out.decode('utf-8', errors='ignore')
              except subprocess.CalledProcessError:
                  return None

          paths = ['app/build.gradle', 'app/build.gradle.kts', 'gradle.properties', 'app/src/main/AndroidManifest.xml']

          text_head = None
          for p in paths:
              content = get_file_at_rev(p, None)
              if content:
                  text_head = content
                  break
          vn_head, vc_head = parse_versions(text_head)

          prev_rev = os.environ.get('GITHUB_EVENT_BEFORE') or 'HEAD^'
          text_prev = None
          for p in paths:
              content = get_file_at_rev(p, prev_rev)
              if content:
                  text_prev = content
                  break
          vn_prev, vc_prev = parse_versions(text_prev)

          # åªæ£€æŸ¥ versionCode æ˜¯å¦å˜åŒ–
          changed = False
          if vc_head and (vc_head != (vc_prev or '')):
              changed = True

          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f'version_name={vn_head or ""}\n')
              f.write(f'version_code={vc_head or ""}\n')
              f.write(f'prev_version_name={vn_prev or ""}\n')
              f.write(f'prev_version_code={vc_prev or ""}\n')
              f.write(f'changed={"true" if changed else "false"}\n')
          PY

      - name: Check if version changed
        if: steps.version.outputs.changed != 'true'
        run: |
          echo "::notice::versionCode æœªå˜åŒ– (å½“å‰: ${{ steps.version.outputs.version_code }}),è·³è¿‡æ„å»ºå’Œå‘å¸ƒæµç¨‹"
          echo "â„¹ï¸ versionCode æœªå˜åŒ–,è·³è¿‡ release"
          echo "ğŸ“Œ å½“å‰ç‰ˆæœ¬: ${{ steps.version.outputs.version_name }} (versionCode: ${{ steps.version.outputs.version_code }})"
          echo "ğŸ“Œ ä¸Šä¸€ç‰ˆæœ¬: ${{ steps.version.outputs.prev_version_name }} (versionCode: ${{ steps.version.outputs.prev_version_code }})"
          echo "ğŸ’¡ æç¤º: åªæœ‰å½“ versionCode å‘ç”Ÿå˜åŒ–æ—¶æ‰ä¼šè§¦å‘æ„å»ºå’Œå‘å¸ƒ"

      - name: Compose current tag
        if: steps.version.outputs.changed == 'true'
        id: tag
        run: |
          V="${{ steps.version.outputs.version_name }}"
          if [ -z "$V" ]; then V="${{ steps.version.outputs.version_code }}"; fi
          if [ -z "$V" ]; then V="$(date +%Y%m%d)-${{ github.sha }}"; fi
          echo "tag=v$V" >> "$GITHUB_OUTPUT"
          echo "version_display=$V" >> "$GITHUB_OUTPUT"
          echo "å½“å‰ tag: v$V"

      - name: Extract changelog from CHANGELOG.md
        if: steps.version.outputs.changed == 'true'
        id: changelog
        run: |
          VERSION="${{ steps.version.outputs.version_name }}"
          CURRENT_TAG="${{ steps.tag.outputs.tag }}"

          echo "ğŸ“– ä» CHANGELOG.md æå–ç‰ˆæœ¬ $VERSION çš„æ›´æ–°å†…å®¹..."

          # ä½¿ç”¨ Python æå– CHANGELOG.md å’Œ CHANGELOG_EN.md ä¸­å¯¹åº”ç‰ˆæœ¬çš„å†…å®¹
          python3 - <<'PY'
          import os
          import re

          version = os.environ.get('VERSION', '')
          current_tag = os.environ.get('CURRENT_TAG', '')

          def extract_version_notes(changelog_file, version):
              """ä» CHANGELOG æ–‡ä»¶ä¸­æå–æŒ‡å®šç‰ˆæœ¬çš„æ›´æ–°å†…å®¹"""
              try:
                  with open(changelog_file, 'r', encoding='utf-8') as f:
                      content = f.read()
              except FileNotFoundError:
                  print(f"âš ï¸ {changelog_file} ä¸å­˜åœ¨")
                  return ""

              if not content or not version:
                  return ""

              # åŒ¹é…ç‰ˆæœ¬æ ‡é¢˜: ## vX.X.X (YYYY-MM-DD) æˆ– ## vX.X.X
              # æå–ä»å½“å‰ç‰ˆæœ¬æ ‡é¢˜åˆ°ä¸‹ä¸€ä¸ª --- æˆ–ä¸‹ä¸€ä¸ªç‰ˆæœ¬æ ‡é¢˜ä¹‹é—´çš„å†…å®¹
              pattern = rf'(## v?{re.escape(version)}[^\n]*\n)(.*?)(?=\n---|\n## v|\Z)'
              match = re.search(pattern, content, re.DOTALL)

              if match:
                  return match.group(2).strip()
              return ""

          # æå–ä¸­æ–‡ç‰ˆæ›´æ–°å†…å®¹
          release_notes = extract_version_notes('CHANGELOG.md', version)
          if release_notes:
              print(f"âœ… æ‰¾åˆ°ç‰ˆæœ¬ {version} çš„ä¸­æ–‡æ›´æ–°å†…å®¹ ({len(release_notes)} å­—ç¬¦)")
          else:
              release_notes = f"ç‰ˆæœ¬ {version} å·²å‘å¸ƒ"
              print(f"â„¹ï¸ ä½¿ç”¨é»˜è®¤ä¸­æ–‡æ›´æ–°è¯´æ˜")

          # æå–è‹±æ–‡ç‰ˆæ›´æ–°å†…å®¹
          release_notes_en = extract_version_notes('CHANGELOG_EN.md', version)
          if release_notes_en:
              print(f"âœ… æ‰¾åˆ°ç‰ˆæœ¬ {version} çš„è‹±æ–‡æ›´æ–°å†…å®¹ ({len(release_notes_en)} å­—ç¬¦)")
          else:
              release_notes_en = f"Version {version} released"
              print(f"â„¹ï¸ ä½¿ç”¨é»˜è®¤è‹±æ–‡æ›´æ–°è¯´æ˜")

          # å†™å…¥ release_notes_short.txtï¼ˆä¸­æ–‡ï¼‰ä¾› version.json ä½¿ç”¨
          with open('release_notes_short.txt', 'w', encoding='utf-8') as f:
              f.write(release_notes)

          # å†™å…¥ release_notes_en_short.txtï¼ˆè‹±æ–‡ï¼‰ä¾› version.json ä½¿ç”¨
          with open('release_notes_en_short.txt', 'w', encoding='utf-8') as f:
              f.write(release_notes_en)

          # ç”Ÿæˆ changelog.md ç”¨äº GitHub Releaseï¼ˆåŒ…å«ä¸­è‹±æ–‡ï¼‰
          with open('changelog.md', 'w', encoding='utf-8') as f:
              f.write(f"## ğŸ“ æ›´æ–°æ—¥å¿— / Changelog ({current_tag})\n\n")
              f.write("### ä¸­æ–‡\n\n")
              f.write(release_notes)
              f.write("\n\n---\n\n")
              f.write("### English\n\n")
              f.write(release_notes_en)
              f.write("\n")

          print(f"âœ… changelog.mdã€release_notes_short.txtã€release_notes_en_short.txt å·²ç”Ÿæˆ")
          PY
        env:
          VERSION: ${{ steps.version.outputs.version_name }}
          CURRENT_TAG: ${{ steps.tag.outputs.tag }}

      - name: Set up Android SDK
        if: steps.version.outputs.changed == 'true'
        uses: android-actions/setup-android@v3
        with:
          api-level: 36
          build-tools: 36.0.0

      - name: Check if keystore is configured
        if: steps.version.outputs.changed == 'true'
        id: check_keystore
        env:
          KEYSTORE_BASE64: ${{ secrets.KEYSTORE_BASE64 }}
        run: |
          if [ -n "$KEYSTORE_BASE64" ]; then
            echo "has_keystore=true" >> "$GITHUB_OUTPUT"
            echo "âœ… æ£€æµ‹åˆ°ç­¾åå¯†é’¥é…ç½®"
          else
            echo "has_keystore=false" >> "$GITHUB_OUTPUT"
            echo "âš ï¸ æœªé…ç½®ç­¾åå¯†é’¥,å°†æ„å»º Debug APK"
          fi

      - name: Decode and setup keystore
        if: steps.version.outputs.changed == 'true' && steps.check_keystore.outputs.has_keystore == 'true'
        env:
          KEYSTORE_BASE64: ${{ secrets.KEYSTORE_BASE64 }}
        run: |
          echo "è§£ç ç­¾åå¯†é’¥..."
          echo "$KEYSTORE_BASE64" | base64 -d > release.keystore
          echo "KEYSTORE_FILE=${{ github.workspace }}/release.keystore" >> $GITHUB_ENV
          ls -lh release.keystore

      - name: Make Gradle wrapper executable
        if: steps.version.outputs.changed == 'true'
        run: |
          chmod +x ./gradlew || true
          sed -i -e 's/\r$//' ./gradlew || true

      - name: Build Release APK with signing
        if: steps.version.outputs.changed == 'true' && steps.check_keystore.outputs.has_keystore == 'true'
        env:
          KEYSTORE_FILE: ${{ env.KEYSTORE_FILE }}
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
          SF_FREE_API_KEY: ${{ secrets.SF_FREE_API_KEY }}
        run: |
          echo "ä½¿ç”¨ç­¾åå¯†é’¥æ„å»º Release APK..."
          ./gradlew --no-daemon clean :app:assembleRelease
          ls -lah app/build/outputs/apk/release/ || true

      - name: Build Debug APK (fallback)
        if: steps.version.outputs.changed == 'true' && steps.check_keystore.outputs.has_keystore != 'true'
        env:
          SF_FREE_API_KEY: ${{ secrets.SF_FREE_API_KEY }}
        run: |
          echo "æœªé…ç½®ç­¾åå¯†é’¥,æ„å»º Debug APK..."
          ./gradlew --no-daemon clean :app:assembleDebug

      - name: Locate built APK
        if: steps.version.outputs.changed == 'true'
        id: locate_apk
        run: |
          # ä¼˜å…ˆæŸ¥æ‰¾ release APK
          RELEASE_APK=$(ls app/build/outputs/apk/release/*.apk 2>/dev/null | grep -v unaligned | head -n 1 || true)
          DEBUG_APK=$(ls app/build/outputs/apk/debug/*.apk 2>/dev/null | head -n 1 || true)

          if [ -n "$RELEASE_APK" ]; then
            APK_PATH="$RELEASE_APK"
            APK_TYPE="release"
          elif [ -n "$DEBUG_APK" ]; then
            APK_PATH="$DEBUG_APK"
            APK_TYPE="debug"
          else
            APK_PATH=""
            APK_TYPE="none"
          fi

          echo "apk_path=$APK_PATH" >> "$GITHUB_OUTPUT"
          echo "apk_type=$APK_TYPE" >> "$GITHUB_OUTPUT"

          if [ -n "$APK_PATH" ]; then
            echo "æ‰¾åˆ° APK ($APK_TYPE): $APK_PATH"
            ls -lh "$APK_PATH"
          else
            echo "æœªæ‰¾åˆ° APK æ–‡ä»¶"
          fi

      - name: Rename APK
        if: steps.version.outputs.changed == 'true' && steps.locate_apk.outputs.apk_path != ''
        id: rename_apk
        run: |
          APK_PATH="${{ steps.locate_apk.outputs.apk_path }}"
          APK_TYPE="${{ steps.locate_apk.outputs.apk_type }}"
          VERSION="${{ steps.version.outputs.version_name }}"

          # ç”Ÿæˆæ–°æ–‡ä»¶å
          NEW_NAME="lexisharp-keyboard-${VERSION}-${APK_TYPE}.apk"
          NEW_PATH="app/build/outputs/apk/${NEW_NAME}"

          cp "$APK_PATH" "$NEW_PATH"
          echo "renamed_apk_path=$NEW_PATH" >> "$GITHUB_OUTPUT"
          echo "é‡å‘½å APK: $NEW_NAME"
          ls -lh "$NEW_PATH"

      - name: Update version.json
        if: steps.version.outputs.changed == 'true'
        id: update_version_json
        run: |
          echo "ğŸ“ æ›´æ–° version.json æ–‡ä»¶..."

          # ä½¿ç”¨ Python ç”Ÿæˆ JSONï¼ˆç¡®ä¿æ ¼å¼æ­£ç¡®ï¼‰
          python3 - <<'PY'
          import json
          import os
          from datetime import datetime

          version = os.environ.get('VERSION', '0.0.0')
          version_code = os.environ.get('VERSION_CODE', '0')
          tag = os.environ.get('TAG', 'v0.0.0')

          # ä»ä¹‹å‰æå–çš„ release_notes_short.txt è¯»å–ï¼ˆæ¥æºäº CHANGELOG.mdï¼‰
          try:
              with open('release_notes_short.txt', 'r', encoding='utf-8') as f:
                  release_notes = f.read().strip()
          except FileNotFoundError:
              release_notes = f'ç‰ˆæœ¬ {version} å·²å‘å¸ƒ'

          # ä»ä¹‹å‰æå–çš„ release_notes_en_short.txt è¯»å–ï¼ˆæ¥æºäº CHANGELOG_EN.mdï¼‰
          try:
              with open('release_notes_en_short.txt', 'r', encoding='utf-8') as f:
                  release_notes_en = f.read().strip()
          except FileNotFoundError:
              release_notes_en = f'Version {version} released'

          # ä½¿ç”¨ ISO 8601 æ ¼å¼çš„æ—¶é—´æˆ³ï¼ˆUTCï¼‰
          current_timestamp = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ')

          # è¯»å–ç°æœ‰çš„ version.jsonï¼ˆå¦‚æœå­˜åœ¨ï¼‰
          try:
              with open('version.json', 'r', encoding='utf-8') as f:
                  data = json.load(f)
          except (FileNotFoundError, json.JSONDecodeError):
              data = {}

          # æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯
          data['version'] = version
          data['version_code'] = int(version_code) if version_code.isdigit() else 0
          data['download_url'] = f"https://github.com/BryceWG/BiBi-Keyboard/releases/tag/{tag}"
          data['release_notes'] = release_notes
          data['release_notes_en'] = release_notes_en
          data['min_supported_version'] = data.get('min_supported_version', '2.6.5')
          data['update_time'] = current_timestamp

          # å†™å…¥æ–‡ä»¶
          with open('version.json', 'w', encoding='utf-8') as f:
              json.dump(data, f, ensure_ascii=False, indent=2)

          print(f"âœ… version.json å·²æ›´æ–°ä¸ºç‰ˆæœ¬ {version}")
          PY

          # æ˜¾ç¤ºæ›´æ–°åçš„å†…å®¹
          echo "ğŸ“„ version.json å†…å®¹:"
          cat version.json

          # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æœ‰å˜åŒ–
          if git diff --quiet version.json; then
            echo "version_changed=false" >> "$GITHUB_OUTPUT"
            echo "â„¹ï¸ version.json æ— å˜åŒ–"
          else
            echo "version_changed=true" >> "$GITHUB_OUTPUT"
            echo "âœ… version.json å·²æ›´æ–°"
          fi
        env:
          VERSION: ${{ steps.version.outputs.version_name }}
          VERSION_CODE: ${{ steps.version.outputs.version_code }}
          TAG: ${{ steps.tag.outputs.tag }}

      - name: Commit and push version.json
        if: steps.version.outputs.changed == 'true' && steps.update_version_json.outputs.version_changed == 'true'
        run: |
          echo "ğŸ“¤ æäº¤ version.json æ›´æ–°..."

          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # æœ€å¤šé‡è¯• 3 æ¬¡
          MAX_RETRIES=3
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "ğŸ”„ å°è¯•æ¨é€ (ç¬¬ $((RETRY_COUNT + 1)) æ¬¡)..."

            # æ‹‰å–æœ€æ–°çš„è¿œç¨‹æ›´æ”¹
            git fetch origin ${{ github.ref_name }}
            git reset --hard origin/${{ github.ref_name }}

            # é‡æ–°åº”ç”¨ version.json æ›´æ”¹ï¼ˆä» release_notes_short.txt å’Œ release_notes_en_short.txt è¯»å–å·²æå–çš„å†…å®¹ï¼‰
            python3 - <<'PY'
          import json
          import os
          from datetime import datetime

          version = os.environ.get('VERSION', '0.0.0')
          version_code = os.environ.get('VERSION_CODE', '0')
          tag = os.environ.get('TAG', 'v0.0.0')

          # ä»ä¹‹å‰æå–çš„ release_notes_short.txt è¯»å–
          try:
              with open('release_notes_short.txt', 'r', encoding='utf-8') as f:
                  release_notes = f.read().strip()
          except FileNotFoundError:
              release_notes = f'ç‰ˆæœ¬ {version} å·²å‘å¸ƒ'

          # ä»ä¹‹å‰æå–çš„ release_notes_en_short.txt è¯»å–
          try:
              with open('release_notes_en_short.txt', 'r', encoding='utf-8') as f:
                  release_notes_en = f.read().strip()
          except FileNotFoundError:
              release_notes_en = f'Version {version} released'

          current_timestamp = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ')

          try:
              with open('version.json', 'r', encoding='utf-8') as f:
                  data = json.load(f)
          except (FileNotFoundError, json.JSONDecodeError):
              data = {}

          data['version'] = version
          data['version_code'] = int(version_code) if version_code.isdigit() else 0
          data['download_url'] = f"https://github.com/BryceWG/BiBi-Keyboard/releases/tag/{tag}"
          data['release_notes'] = release_notes
          data['release_notes_en'] = release_notes_en
          data['min_supported_version'] = data.get('min_supported_version', '2.6.5')
          data['update_time'] = current_timestamp

          with open('version.json', 'w', encoding='utf-8') as f:
              json.dump(data, f, ensure_ascii=False, indent=2)
          PY

            # æ£€æŸ¥æ˜¯å¦æœ‰å˜åŒ–
            if git diff --quiet version.json; then
              echo "â„¹ï¸ version.json æ— å˜åŒ–ï¼Œæ— éœ€æ¨é€"
              break
            fi

            # æäº¤æ›´æ”¹
            git add version.json
            git commit -m "chore: auto-update version.json to ${{ steps.version.outputs.version_name }} [skip ci]"

            # å°è¯•æ¨é€
            if git push origin HEAD:${{ github.ref_name }}; then
              echo "âœ… version.json å·²æˆåŠŸæ¨é€"
              break
            else
              echo "âš ï¸ æ¨é€å¤±è´¥ï¼Œå¯èƒ½å­˜åœ¨å†²çª"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "â³ ç­‰å¾… 5 ç§’åé‡è¯•..."
                sleep 5
              else
                echo "âŒ è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œæ¨é€å¤±è´¥"
                exit 1
              fi
            fi
          done
        env:
          VERSION: ${{ steps.version.outputs.version_name }}
          VERSION_CODE: ${{ steps.version.outputs.version_code }}
          TAG: ${{ steps.tag.outputs.tag }}

      - name: Create GitHub Release
        if: steps.version.outputs.changed == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          name: "Release ${{ steps.tag.outputs.version_display }}"
          body_path: changelog.md
          files: ${{ steps.rename_apk.outputs.renamed_apk_path }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
